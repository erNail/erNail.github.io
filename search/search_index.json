{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Greetings! My name is Eric Nagel. I'm a seasoned professional in the domains of Site Reliability, DevOps, and Software Engineering.</p> <p>My expertise spans a wide range of tools, languages, and technologies. These include Kubernetes, Helm Charts, Gitlab CI/CD, Terraform, Ansible, Prometheus, Grafana, Containerization, Typescript, JavaScript, Node.js, Angular, Java, and Spring Boot.</p> <p>My philosophy is rooted in the belief that high-quality standards must be maintained throughout the entire DevOps cycle, achieved through a series of practices. You will find these explained in detail here:</p> <ul> <li>Everything as Code</li> <li>Linting and Formatting</li> <li>Testing</li> <li>Commit Messages</li> <li>Release Automation</li> <li>Code Reviews</li> <li>CI/CD Pipelines</li> <li>Monitoring</li> <li>Blameless Post Mortem</li> <li>Documentation as Code</li> </ul>"},{"location":"philosophies/blameless-post-mortem/","title":"Blameless Post Mortem","text":"<p>In the event of service outages, conducting a blameless post mortem is an essential practice. Its purpose is to analyze why the outage occurred, in a manner that focuses on learning and prevention, rather than attributing blame.</p> <p>The goal is to understand exactly what happened, the contributing factors, and most importantly, what actions can be taken to prevent similar issues in the future.</p> <p>Embracing a blameless culture fosters an environment of openness and continuous learning. It encourages team members to share their experiences and insights, which can be instrumental in enhancing system resilience and reliability.</p>"},{"location":"philosophies/ci-cd-pipelines/","title":"CI / CD Pipelines","text":"<p>CI/CD pipelines are key to a highly automated DevOps cycle. They serve as the backbone of efficient and reliable software delivery processes.</p> <p>Upon each code change, several actions should automatically occur. The code should be linted and formatted, ensuring it adheres to defined standards and is consistently structured.</p> <p>Next, automated tests should run, verifying the integrity and functionality of the changes.</p> <p>Following successful tests, the code should be built, packaged, and appropriately versioned.</p> <p>Finally, the new version of the application should be automatically released and deployed. This process ensures every change is rapidly and safely delivered to the production environment.</p> <p>The \"Everything as Code\" philosophy greatly enhances the effectiveness of CI/CD pipelines, as it extends the automation to all aspects of the project.</p>"},{"location":"philosophies/code-reviews/","title":"Code Reviews","text":"<p>Code reviews are a critical part of the software development process. They provide an opportunity for team members to improve the quality of the code, leveraging different experiences and perspectives.</p> <p>In a code review, the likelihood of identifying human errors increases. This is due to the diversity of the reviewers' backgrounds and the additional pairs of eyes inspecting the changes.</p> <p>Code reviews also foster knowledge sharing among team members. Through these sessions, experiences and opinions are exchanged, contributing to the collective knowledge of the team.</p> <p>For code reviews to be efficient, it is beneficial to conduct them in a pair programming format. This approach can expedite the review process and reduce misunderstandings between the reviewers and the reviewee.</p>"},{"location":"philosophies/commit-messages/","title":"Commit Messages","text":"<p>Commit messages are essential in any software development project. They ensure clarity and traceability by providing a well-documented history of changes in the codebase.</p> <p>When troubleshooting issues, these commit messages offer a quick overview of recent modifications that could have contributed to the problem, aiding in the debugging process.</p> <p>Additionally, consistent and thoughtful commit messages can be beneficial in automating the release process.</p>"},{"location":"philosophies/documentation-as-code/","title":"Documentation as Code","text":"<p>Documentation often poses a challenge for many teams, yet its importance cannot be understated, particularly for those on-call. Effective documentation can expedite the response to outages and minimize downtime.</p> <p>One approach that I have found to be effective is treating documentation as code and including it within the Git repositories. This practice increases the likelihood of keeping documentation updated as changes are made in the repository.</p> <p>Having documentation within the repository currently being worked on, rather than tucked away in another tool or hidden subpages, makes it more accessible and convenient to maintain.</p> <p>Tools like 'mkdocs-material' are particularly useful for generating searchable, well-structured, and visually appealing documentation from Markdown files. For instance, this website is generated entirely from Markdown files.</p>"},{"location":"philosophies/everything-as-code/","title":"Everything as Code","text":"<p>The philosophy of \"Everything as Code\" expands the idea of \"Infrastructure as Code\" to every aspect of a project. This approach treats elements like software, infrastructure, configuration, documentation, environments, pipelines, diagrams, dashboards, alerts, VM images and so on as code. This method offers significant advantages in DevOps and Site Reliability.</p> <p>Repeatability: A clear benefit of \"Everything as Code\" is its ability to simplify replication. Consider the process of creating new VMs on a cloud provider. Normally, this involves manual setup and extensive documentation for replication. By treating the setup as code, we can replicate the environment creation more effectively using tools like Terraform or Ansible.</p> <p>Efficiency: Code-based modification of systems reduces the likelihood of errors compared to manual adjustments. Changes can be made by altering a few lines of code and deploying these changes, which is simpler than manually logging into each VM and changing settings.</p> <p>Scalability: Manual methods of management become increasingly difficult as the number of components increases. Treating everything as code allows for integrated scalability. The task of creating and configuring 100 VMs changes from a manual process to a code deployment.</p> <p>Auditability: Version control is essential for effective change tracking. When code encompasses everything, it allows for a clear, traceable history.  This feature assists in identifying sources of issues over time.</p> <p>Recoverability: Version-controlled code can be rolled back to a previous state when necessary. If a deployed change causes issues, reverting to a previous version is straightforward.</p> <p>Quality: Applying linters and formatters to everything treated as code can help enforce best practices and identify potential security vulnerabilities. This approach can improve the overall quality of the project.</p>"},{"location":"philosophies/linting-and-formatting/","title":"Linting and Formatting","text":"<p>Linting and formatting are essential components in ensuring best practices, security, readability, and efficiency. They play a vital role in different areas of the DevOps cycle.</p> <p>Best Practices: No engineer, regardless of skill level, can remember all best practices for languages and tools like Go, Terraform, Ansible, Helm and so on. Linters step in here, offering reminders when code deviates from these best practices.</p> <p>Security: Similarly, it's not feasible for an engineer to recall every potential security vulnerability. Linters help by flagging code that may introduce security risks, assisting in maintaining a secure codebase.</p> <p>Readability: Consistent formatting enhances the readability and maintainability of code. Formatters automate this process, ensuring all code adheres to a uniform style.</p> <p>Efficiency: Linters and formatters not only identify issues but can also fix many of them automatically. This automation reduces the amount of manual work needed and streamlines code reviews, eliminating debates over code formatting.</p> <p>As we apply the \"Everything as Code\" philosophy, the need for linting and formatting extends beyond application code. Markdown files, YAML files, Helm charts, Terraform code, Ansible code and so on should all be subject to the same level of linting and formatting. In this way, we maintain consistency and high standards across all project components.</p>"},{"location":"philosophies/monitoring/","title":"Monitoring","text":"<p>Monitoring is crucial once services are deployed and Service Level Agreement (SLA) commitments are in place. Not only is it important to monitor the services themselves, but also the infrastructure they run on.</p> <p>Dashboards provide a comprehensive overview of the behavior of the services and the underlying infrastructure. They offer real-time visibility into the performance and status of the system, enabling swift identification and resolution of issues.</p> <p>Alerts, coupled with an on-call duty roster, allow for quick reactions to any service outages. This proactive approach helps in maintaining the uptime and reliability of the services.</p> <p>Log aggregation is a critical tool for gaining deeper insights into the behavior of the services. It facilitates the collection, processing, and analysis of log data, which can be instrumental in troubleshooting and performance optimization.</p> <p>As part of the \"Everything as Code\" philosophy, monitoring tools and configurations should also be managed as code. This approach ensures consistent monitoring settings across environments and aids in maintaining high standards of service performance and reliability.</p>"},{"location":"philosophies/release-automation/","title":"Release Automation","text":"<p>The tasks associated with software releases, such as determining new version numbers, writing changelogs, and releasing new packages, can be time-consuming and prone to manual errors. Automation can significantly increase efficiency and reduce the likelihood of mistakes in this process.</p> <p>One way to achieve this is by utilizing tools like <code>semantic-release</code>. This tool can automatically determine the new version number from commit messages, generate the changelog likewise, and perform the release.</p>"},{"location":"philosophies/testing/","title":"Testing","text":"<p>Automated testing plays a crucial role in preventing bugs and issues from making their way into a production environment. As software projects grow and new features are integrated, the likelihood of unexpected behaviors or breaks increases. Automated tests are designed to identify issues early. This early detection enables teams to fix problems at the development stage, reducing the risk of production failures.</p> <p>In the context of the \"Everything as Code\" philosophy, automated testing becomes even more critical. With everything from code to configurations being part of the testing process, we can ensure a high level of reliability across all project components.</p>"}]}